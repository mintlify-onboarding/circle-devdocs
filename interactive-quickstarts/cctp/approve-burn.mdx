As a result of interacting with the TokenMessenger contract, Circle generates a
unique ID for the transaction. Starting with the returned transaction ID, you
call Circle's Attestation service to fetch an attestation that the burn took
place. This attestation proves that the USDC was removed from circulation on the
source chain.

<Note>
  The transactionId returned is a unique transaction ID generated by Circle. It
  is distinct from the unique identifier that is used to track the transaction
  on the blockchain - known as the transaction hash.
</Note>

The attestation is used on the destination chain to mint new USDC. You can make
API calls to get the transaction's `transactionHash`, retrieve the logs of the
`depositForBurn` transaction, and use Circle's Attestation API to fetch the
attestation signature. The steps have been broken down for you here, but you can
use the following "Try It Out" component to run all of these steps together.

<OrderedList>
  <OrderedListStep title="Fetching the Deposit Transaction Object from the Wallets API.">
    Call the Wallets API to fetch the transaction object for the `depositForBurn` transaction. Make a GET request using the provided code and the transaction ID. Retrieve the transaction object from the response data.
    <RequestTemplate
      config={{
        method: 'GET',
        url: '/v1/w3s/transactions/__TRANSACTION_ID__',
        headers: {
          'Content-Type': 'application/json',
          Authorization: 'Bearer <YOUR_API_KEY>',
        },
      }}
      title="Fetch the transaction object"
    />
  </OrderedListStep>
  <OrderedListStep title="Decoding and Creating messageBytes and messageHash with a Web3 Library">
    Using a Web3 library like <Link path="https://www.npmjs.com/package/web3" type="external">web3</Link> or <Link path="https://www.npmjs.com/package/ethers" type="external">ethers</Link>, decode and create `messageBytes` and `messageHash` from the transaction object's `txHash`. Follow the provided code snippet to extract the relevant information.

    ```js
    // get messageBytes from EVM logs using txHash of the transaction.
    const transactionReceipt = await web3.eth.getTransactionReceipt(
    transaction.txHash,
    )
    const eventTopic = web3.utils.keccak256('MessageSent(bytes)')
    const log = transactionReceipt.logs.find((l) => l.topics[0] === eventTopic)
    const messageBytes = web3.eth.abi.decodeParameters(['bytes'], log.data)[0]
    const messageHash = web3.utils.keccak256(messageBytes)
    ```

  </OrderedListStep>
  <OrderedListStep title="Fetch Attestation Signature from Circle's Iris API">
    Retrieve the attestation signature from Circle's Iris API using the `messageHash` obtained in the previous step. Use the provided code inside a loop to query the API until the attestation status is "complete". Access the attestation signature from the response.

    ```js
    // Get attestation signature from iris-api.circle.com
    let attestationResponse = { status: 'pending' }
    while (attestationResponse.status != 'complete') {
      const response = await fetch(
        `https://iris-api-sandbox.circle.com/attestations/${messageHash}`,
      )
      attestationResponse = await response.json()
      await new Promise((r) => setTimeout(r, 2000))
    }
    ```

    <Warning>
      The attestation service is rate-limited. Please limit your requests to less
      than 10 per second.
    </Warning>

  </OrderedListStep>
</OrderedList>

<Note>
  Message hash refers to the cryptographic value that represents the specific
  message related to the USDC burn transaction. It serves as a fingerprint of
  the transaction and helps ensure its integrity and authenticity. The message
  hash plays a crucial role in verifying and validating the burn transaction on
  the source blockchain, allowing participants to track and confirm the
  successful burning of tokens. As a developer, you will need to generate the
  message hash using the Keccak-256 hash of the bytes emitted by the
  `MessageSent` event, as shown previously.
</Note>

<Playground
  title="Fetch Attestation"
  url="/quickstarts/api/cctp/attestation"
  copy={[
    { path: 'messageBytes', key: 'cctpMessageBytes' },
    { path: 'attestation', key: 'cctpAttestation' },
  ]}
/>
