{/* <!-- markdownlint-disable --> */}

The Entity Secret is an integral component in developer-controlled wallets,
serving as a key element in bolstering security.

### What is the Entity Secret?

The Entity Secret is a robust 32-byte key engineered to enhance the security
mechanisms of developer-controlled wallets. Its value lies not only in its
complexity but also in the specific security benefits it confers.

### The importance of the Entity Secret

<Features variant="list" background="light">
  <Features.Feature icon="LockClosedSolid">
    <Features.Feature.Title>Exclusivity</Features.Feature.Title>
    <Features.Feature.Description>
      The Entity Secret is generated by you and remains known exclusively to
      you. Consider it as your private password or a cryptographic signature
      that distinguishes your activities.
    </Features.Feature.Description>
  </Features.Feature>

  <Features.Feature icon="ShieldCheckOutline">
    <Features.Feature.Title>
      Enhanced Security for Critical API Requests
    </Features.Feature.Title>
    <Features.Feature.Description>
      For critical actions such as wallet creation or initiating transactions,
      the Entity Secret comes into play. Attaching an encrypted version of the
      Entity Secret to these API requests provides an added authentication
      factor, reinforcing the security infrastructure.
    </Features.Feature.Description>
  </Features.Feature>
  <Features.Feature icon="KeyOutline">
    <Features.Feature.Title>Dynamic Protection</Features.Feature.Title>
    <Features.Feature.Description>
      With a requirement to re-encrypt the Entity Secret for each API request,
      you avoid the risks associated with having a static key, which could be
      vulnerable to security breaches. This dynamic approach means that every
      request is identifiably distinct, providing fortified protection against
      potential attacks.
    </Features.Feature.Description>
  </Features.Feature>
  <Features.Feature icon="UserOutline">
    <Features.Feature.Title>Sole Authority</Features.Feature.Title>
    <Features.Feature.Description>
      While our platform enables operations using the Entity Secret, it does not
      store it. This design choice comes with dual implications: First, it
      ensures you are the sole entity capable of using your private keys, thus
      preserving absolute control over them. Second, it places the
      responsibility squarely on your shoulders to secure the Entity Secret
      conscientiously, as its security is paramount to the overall protection of
      your developer-controlled wallets.
    </Features.Feature.Description>
  </Features.Feature>
</Features>

### Balancing Power with Responsibility as a Developer

The Entity Secret embodies the level of trust and authority that our platform
confers upon developers. It enables smooth access to the extensive capabilities
of developer-controlled wallets, while simultaneously ensuring their security is
maintained. However, great power necessitates equally great responsibility. The
safeguarding, encryption, and periodic renewal of the Entity Secret are duties
that rest with you, the developer.

This dynamic of empowering developers while also entrusting them with critical
security tasks reflects the core principles of decentralization intrinsic to the
web3 ecosystem. As a developer, you're more than a creator; you assume the role
of a guardian of security and a proponent of distributed authority.

<Note>

Should you sense the weight of this role, rest assured that guidance is at hand.
We are here to support you in effectively managing and protecting your Entity
Secret.

</Note>

### Generating the Entity Secret

<CodeGroup>

```javascript NodeJS SDK
import { generateEntitySecret } from "@circle-fin/developer-controlled-wallets";
// This will print a new entity secret in the terminal
generateEntitySecret();
```

```python Python SDK
from circle.web3 import utils
# This will print a new entity secret in the terminal
utils.generate_entity_secret()
```

{/* prettier-ignore-start */}

  <CodePanel language="node" code={`import crypto from "crypto";
  
const secret = crypto.randomBytes(32).toString('hex')

console.log(secret)
`} />
  <CodePanel language="js" code={`let array = new Uint8Array(32)
window.crypto.getRandomValues(array)
let secret = Array.from(array)
  .map((b) => b.toString(16).padStart(2, '0'))
  .join('')

console.log(secret) `} />

  <CodePanel language="bash" code="openssl rand -hex 32" />
  <CodePanel language="python" code={`import os

secret = os.urandom(32).hex()

print(secret) `} />

  <CodePanel language="go" code={`package main

import (
	"crypto/rand"
	"fmt"
	"io"
)

func generateRandomHex() []byte { 
  mainBuff := make([]byte, 32) 
  _, err := io.ReadFull(rand.Reader, mainBuff) 
  if err != nil { 
    panic("reading from crypto/rand failed: " + err.Error())
  }
  return mainBuff
}

// The following sample codes generate a distinct hex encoded entity secret with each execution
// The generation of entity secret only need to be executed once unless you need to rotate entity secret.
func main() { 
  entitySecret := generateRandomHex()
  fmt.Printf("Hex encoded entity secret: %x\n", entitySecret)
}`
} />

</CodeGroup>

{/* prettier-ignore-end */}

<Playground
  title="Generate your own Entity Secret"
  url="/quickstarts/api/common/entity-secret"
/>

<Warning>

It's crucial to safeguard your Entity Secret akin to a key to your
home—misplacing it or divulging it to others could have serious ramifications.
Ensure you securely store the Entity Secret because you'll require it shortly to
create an Entity Secret Ciphertext. Just as the name implies, the Entity Secret
is sensitive information; treat it with the utmost confidentiality and security
to prevent unauthorized access or use.

</Warning>

With your Entity Secret now created, we're ready to advance to a critical
juncture. You're about to convert the Entity Secret into Ciphertext and register
it with the system. This process sets the stage for you to create your first
wallet—a milestone to look forward to.

### Retrieving Your Entity's Public Key (Optional if registering with SDK)

Begin by acquiring your entity's public key. This key is retrievable via our
APIs and is instrumental in the upcoming steps. To obtain it, use your API key
for authentication. The entity's public key plays a crucial role as it encrypts
your Entity Secret. Once encrypted, the Entity Secret remains secure, ensuring
the information is shared exclusively between you and the platform, keeping it
out of reach from outsiders.

<Playground
  title="Fetching your public key"
  url="/quickstarts/api/common/public-key"
  config={{
    method: "GET",
    url: "/v1/w3s/config/entity/publicKey",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer <YOUR_API_KEY>",
    },
  }}
/>

### Encrypting the Entity Secret and Encoding in Base64 (Optional if registering with SDK)

After obtaining the public key, the next step involves using RSA encryption to
secure your Entity Secret. Follow these steps:

<OrderedList>
  <OrderedListStep title="Encrypt the Entity Secret">
    Employ RSA encryption with the public key to encrypt your Entity Secret.
    This cryptographic process ensures that the secret is encoded in such a way
    that only someone with the private key can decrypt it.
  </OrderedListStep>
  <OrderedListStep title="Encode as Base64">
    After encryption, convert the encrypted data into Base64 format. Encoding in
    Base64 ensures the encrypted data can be safely conveyed and interpreted in
    various contexts, including those that may not handle binary data well.
  </OrderedListStep>
  <OrderedListStep title="Verify the Ciphertext Length">
    Ensure that the generated Ciphertext is 684 characters in length. This
    specific length confirms the encryption process has been executed properly
    and that the data will be maintained correctly upon receipt.
  </OrderedListStep>
</OrderedList>

The code provided will assist in automating this encryption process, generating
a unique Entity Secret Ciphertext every time it is executed. The resulting
Ciphertext is what you'll use to interact securely with the platform's API when
performing operations that require it.

{/* prettier-ignore-start */}

<CodeGroup title="Encrypt your Entity Secret">

  <CodePanel language="node" code={`// npm install node-forge -S

import forge from "node-forge";

const entitySecret = forge.util.hexToBytes('YOUR_ENTITY_SECRET');

const publicKey = forge.pki.publicKeyFromPem('YOUR_PUBLIC_KEY');

const encryptedData = publicKey.encrypt(entitySecret, 'RSA-OAEP', { md: forge.md.sha256.create(), mgf1: { md: forge.md.sha256.create(), }, });

console.log(forge.util.encode64(encryptedData)) `} />

  <CodePanel language="python" code={`import base64
import codecs
# Installed by \`pip install pycryptodome\`
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Hash import SHA256

# Paste your entity public key here.
public_key_string = 'PASTE_YOUR_PUBLIC_KEY_HERE'
# If you already have a hex encoded entity secret, you can paste it here. the length of the hex string should be 64.
hex_encoded_entity_secret = 'PASTE_YOUR_HEX_ENCODED_ENTITY_SECRET_KEY_HERE'
# The following sample codes generate a distinct entity secret ciphertext with each execution.
if **name** == '**main**': 
  entity_secret = bytes.fromhex(hex_encoded_entity_secret)
  if len(entity_secret) != 32:
		print("invalid entity secret")
		exit(1)
	public_key = RSA.importKey(public_key_string)

	# encrypt data by the public key
	cipher_rsa = PKCS1_OAEP.new(key=public_key, hashAlgo=SHA256)
	encrypted_data = cipher_rsa.encrypt(entity_secret)

	# encode to base64
	encrypted_data_base64 = base64.b64encode(encrypted_data)
	print("Hex encoded entity secret:", codecs.encode(entity_secret, 'hex').decode())
	print("Entity secret ciphertext:", encrypted_data_base64.decode())
`} />

  <CodePanel language="go" code={`package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/base64"
	"encoding/hex"
	"encoding/pem"
	"errors"
	"fmt"
)
// Paste your entity public key here. var publicKeyString = "PASTE_YOUR_PUBLIC_KEY_HERE"
// If you already have a hex encoded entity secret, you can paste it here. the length of the hex string should be 64. var hexEncodedEntitySecret = "PASTE_YOUR_HEX_ENCODED_ENTITY_SECRET_KEY_HERE"
// The following sample codes generate a distinct entity secret ciphertext with each execution 
func main() { 
  entitySecret, err := hex.DecodeString(hexEncodedEntitySecret) 
  if err != nil { 
    panic(err) 
  } 

  if len(entitySecret) != 32 { 
    panic("invalid entity secret") 
  } 

  pubKey, err := ParseRsaPublicKeyFromPem([]byte(publicKeyString)) 
  if err != nil {
    panic(err)
  } 

  cipher, err := EncryptOAEP(pubKey, entitySecret) 
  if err != nil { 
    panic(err)
  }
  fmt.Printf("Hex encoded entity secret: %x", entitySecret)
  fmt.Printf("Entity secret ciphertext: %s", base64.StdEncoding.EncodeToString(cipher))
}

// ParseRsaPublicKeyFromPem parse rsa public key from pem. 
func ParseRsaPublicKeyFromPem(pubPEM []byte) (\*rsa.PublicKey, error) { 
  block, \_ := pem.Decode(pubPEM) 
  if block == nil { 
    return nil, errors.New("failed to parse PEM block containing the key") 
  }
	pub, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		return nil, err
	}
	switch pub := pub.(type) {
	case *rsa.PublicKey:
		return pub, nil
	default:
	}
	return nil, errors.New("key type is not rsa")
}

// EncryptOAEP rsa encrypt oaep. 
func EncryptOAEP(pubKey \*rsa.PublicKey, message []byte) (ciphertext []byte, err error) 
{ 
  random := rand.Reader 
  ciphertext, err = rsa.EncryptOAEP(sha256.New(), random, pubKey, message, nil) 
  if err != nil {
    return nil, err
  }
  return
}`} />
</CodeGroup>

{/* prettier-ignore-end */}

<Playground
  title="Generate Entity Secret Ciphertext"
  url="/quickstarts/api/common/entity-secret-ciphertext"
/>

### Register the Entity Secret

You can register your Entity Secret in two ways: using the SDK, or using the
Circle Console. The registration links your Entity Secret with your developer
account, ensuring that you can confidently manage wallet creation and
transactions with the assurance of robust security measures in place.

<Warning>
As you proceed with the registration of your Entity Secret, pay close attention to the recovery file that will be generated. This file is a critical safety measure for your operations. In the event that your Entity Secret is ever lost, the recovery file will act as your fallback, enabling you to regain access to your developer-controlled wallets. Ensure that you store this file securely and in a location that you can access readily if needed.

**Note:** If you use the SDK to register the Entity Secret, the function
downloads a recovery file named _recovery*file*\<timestamp\>.dat_. Additionally,
the function returns the content of the recovery file as a JSON response.

</Warning>

### Registering your Entity Secret using the SDK

You can use the sample code below as a guide to register your Entity Secret
Ciphertext using the SDK.

<CodeGroup title="Register your Entity Secret">

```javascript NodeJS SDK
import { registerEntitySecretCiphertext } from "@circle-fin/developer-controlled-wallets";

const response = await registerEntitySecretCiphertext({
  apiKey: "<api-key>",
  entitySecret: "<new-entity-secret>",
});
console.log(response.data?.recoveryFile);
```

```python Python SDK
from circle.web3 import utils

result = utils.register_entity_secret_ciphertext(api_key='your_api_key', entity_secret='new_entity_secret')
print(result)
```

</CodeGroup>

### Registering Your Entity Secret Ciphertext in Developer Services Console

<Note>
  If you want to register the Entity Secret within our Developer Services
  Console, you need to safeguard your Entity Secret first by converting it to
  Ciphertext following the previous instructions.
</Note>

You can use the
[Configurator Page](https://console.circle.com/wallets/dev/configurator) in
Developer Services Console to register your Entity Secret Ciphertext.

<Image
  src="/interactive-quickstarts/dev-controlled-wallets/images/cipher_text_registration.png"
  alt="Testnet"
/>

<ActionCard
  title="Register your Entity Secret Ciphertext"
  actions={[
    {
      label: "Register",
      path: "/wallets/dev/configurator",
      type: "console",
    },
  ]}
/>

### Guarding your secrets & building trust

By meticulously completing the registration and protection of your Entity
Secret, you've not only guaranteed the security of your key but also laid down a
bedrock of trust for all activities involving our developer-controlled wallets.
We prioritize the safety of your data and are committed to providing a seamless
and secure user experience.
